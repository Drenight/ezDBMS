## 0419

### 索引
or的索引比较难用啊，and倒是可以拉一批出来筛
- 或许还好？两个有序的列表merge，相同uuid会连带着相遇的

不过BTree不知道rangeQuery什么复杂度，klogn?肯定没b+树好，咋办，直接扫描吗？

现在用的包又没有logn的rank/kth告诉我名次，很难权衡哪个快啊

那哪里用到index了啊，b树索引感觉好鸡肋

换包吧要不，实在想不出哪里用b树，唯一超越哈希的区间查询还这么慢

找到的能用的b+树都和磁盘强绑定啊，手写的带kth的平衡树疑似都把这b树爆飞了，虽说测试数据只有1e6

## 0420

### 85'
不找新的b+树的话，考虑找个辅助树了，有logn的kth或者rank就可以决策线性扫/平衡树区间查询了

这个功能跟logn主键疑似要一起开关掉，100'(b)

接下来优先级的话应该是
1. 优化器选一个实现下
   - 条件排序有个想法就是count下mismatch数，每次swap用小的，不知道对不对
     - 搜一搜吧，谓词下推都查到了
   - join的排序合并稍微麻烦点感觉，排序不在主键join有小叉积好像，没细想，双指针一样
     - 87分总要做这个的
2. 索引区间查询
   - 可以考虑skip掉
   - 做的话就外面不循环调judge_row

### 100'

A  (94-38)/0.6=93

A- (90-38)/0.6=86

22号ppt得收尾，如果100内容需要有的话可以22夜里开始做，Due Apr 23 at 8:30pm
- 过一遍Implementation ppt

得上个系统的测试
- 大小写之类的把坑排了

优先级参考879095100就好，最乐观还有一周

有空把index支持完整

重构？估计没空

## 0421
条件排序总觉得是个裸的平衡树rank，这b树又不支持
- 自己写treap比较solid工作量大
- 经验方法不solid工作量小

写了treap，给where上了条件优化了，这种办法having上不了估计，因为没索引
- 底层create_index重用了，想把这个优化用满的话CREATE/DROP INDEX需要parse一下

join还没考虑，ppt如果要提的话22号得想一想

还要做的事，大概优先级：
- join优化
- order by / limit
- 聚合函数补齐 max,avg,count,distinct?
- CREATE/DROP INDEX parser
- 测试
- canned
- 索引开关

## 0425
更新了下条件优化的短路逻辑，确实有个**两倍**的快的showcase了，符合预期

估计就25，26两天了，index可以往后放放
- 就showcase主键上的吧？就是白写create_index了

eval字符串是真慢啊，要是有时间还能整体翻新下

目前最慢的就1e5*1e3在50s，join优化上了应该还好

## 0427
- ~~canned补齐，测最大最大~~
- ~~聚合函数补齐~~
- ~~索引开关~~
  - ~~where定位，等值那里确认下~~
- showcase整理 & 测试
  - 应该是最后了